<!doctype html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
    <meta name='mobile-web-app-capable' content='yes'>
    <meta name='apple-mobile-web-app-capable' content='yes'>
    <title>Barebones AR — 3D object, tap to change color, sticky placement</title>
    <style>
      html,body{height:100%;margin:0;background:#111;color:#eee;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
      #overlay{position: absolute; left: 8px; top: 8px; z-index: 10; max-width: 320px; background: rgba(0,0,0,0.45); padding:8px;border-radius:8px;}
      #overlay summary{cursor:pointer}
      #xr-button{margin-top:6px;padding:8px 10px;border-radius:6px;border:none;background:#0a84ff;color:white;font-weight:600}
      #xr-button[disabled]{opacity:0.5;background:#666}
      #session-info, #pose, #warning-zone{font-size:13px;margin-top:6px}
      canvas.three-canvas{position: absolute; inset: 0; width:100%; height:100%; touch-action: none; z-index: 1;}
      main{position: absolute; left:0;right:0;bottom:16px;text-align:center;z-index:9;color:#ccc}
    </style>
  </head>
  <body>
    <div id="overlay">
      <header>
        <details open>
          <summary>Barebones WebXR DOM Overlay — with 3D object</summary>
          <p style="font-size:13px;margin:6px 0;">
            Tap 'Enter AR' to start an AR session. Tap the bright reticle to place the object. Tap the object again to change its color.
          </p>
          <div id="session-info"></div>
          <div id="pose"></div>
          <div id="warning-zone"></div>
          <button id="xr-button" disabled>Checking AR...</button>
        </details>
      </header>
    </div>

    <main>
      <p>Tap the object to change its color. On desktop: drag to orbit, click to place.</p>
    </main>

    <!-- three.js (module build) -->
    <script type="module">
      import * as THREE from 'https://unpkg.com/three@0.155.0/build/three.module.js';
      import { OrbitControls } from 'https://unpkg.com/three@0.155.0/examples/jsm/controls/OrbitControls.js';

      // UI elements
      const xrButton = document.getElementById('xr-button');
      const sessionInfo = document.getElementById('session-info');
      const poseInfo = document.getElementById('pose');
      const warningZone = document.getElementById('warning-zone');

      // three.js globals
      let renderer, scene, camera, controls;
      let reticle = null;
      let object3D = null;           // the main 3D object
      let placed = false;
      let anchor = null;             // XRAnchor if created
      let savedPoseMatrix = null;    // fallback pose matrix if anchors unsupported
      let hitTestSource = null;
      let xrRefSpace = null;
      let xrSession = null;

      let colors = [0x1e90ff, 0xff6b6b, 0x72f0a1, 0xffd86b];
      let colorIndex = 0;

      // Initialize three.js preview (non-AR fallback)
      function initThree() {
        // create renderer
        const canvas = document.createElement('canvas');
        canvas.classList.add('three-canvas');
        document.body.appendChild(canvas);
        renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.xr.enabled = true;

        // scene & camera
        scene = new THREE.Scene();
        scene.background = null; // transparent (AR camera feed will show behind)
        camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);
        camera.position.set(0.8, 0.6, 1.2);

        // lights
        const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        scene.add(hemi);
        const dir = new THREE.DirectionalLight(0xffffff, 0.9);
        dir.position.set(0.5, 2, 0.5);
        scene.add(dir);

        // grid for preview
        const grid = new THREE.GridHelper(3, 24, 0x444444, 0x111111);
        grid.material.opacity = 0.15;
        grid.material.transparent = true;
        scene.add(grid);

        // reticle (invisible until hit)
        const ringGeo = new THREE.RingGeometry(0.06, 0.09, 32).rotateX(-Math.PI/2);
        const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ffcc, opacity:0.85, transparent:true });
        reticle = new THREE.Mesh(ringGeo, ringMat);
        reticle.matrixAutoUpdate = false;
        reticle.visible = false;
        scene.add(reticle);

        // object (complex extruded polygon)
        object3D = createComplexPolygonMesh();
        object3D.visible = true; // preview visible by default
        scene.add(object3D);

        // Orbit controls for desktop
        controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 0.08, 0);
        controls.update();

        // pointer events (touch/click)
        renderer.domElement.addEventListener('click', onPointerClick);

        window.addEventListener('resize', onWindowResize);

        // start render loop
        renderer.setAnimationLoop(render);
      }

      function createComplexPolygonMesh() {
        // build a star-like shape and extrude it (same approach you had before)
        const shape = new THREE.Shape();
        const points = [
          [0, 0.45],
          [0.12, 0.12],
          [0.45, 0],
          [0.12, -0.12],
          [0, -0.45],
          [-0.12, -0.12],
          [-0.45, 0],
          [-0.12, 0.12]
        ];
        shape.moveTo(points[0][0], points[0][1]);
        for (let i=1;i<points.length;i++) shape.lineTo(points[i][0], points[i][1]);
        shape.lineTo(points[0][0], points[0][1]);

        // hole
        const holePath = new THREE.Path();
        holePath.absellipse(0,0,0.08,0.08,0,Math.PI*2,false,0);
        shape.holes.push(holePath);

        const extrudeSettings = { depth: 0.12, bevelEnabled: true, bevelThickness:0.015, bevelSize:0.02, bevelSegments:2 };
        const geom = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        geom.computeVertexNormals();

        const mat = new THREE.MeshStandardMaterial({ color: colors[colorIndex], metalness: 0.3, roughness:0.45, side: THREE.DoubleSide });
        const mesh = new THREE.Mesh(geom, mat);
        mesh.castShadow = true;
        mesh.receiveShadow = false;

        // center so it sits on plane
        geom.computeBoundingBox();
        const min = geom.boundingBox.min;
        mesh.position.y = -min.y + 0.01;

        // make it easier to raycast by setting name and enabling matrix updates
        mesh.name = 'complexPolygon';
        mesh.userData.selectable = true;
        return mesh;
      }

      // Pointer (tap/click) handler — works in both AR and preview
      async function onPointerClick(event) {
        // compute normalized screen coordinates
        const canvas = renderer.domElement;
        const rect = canvas.getBoundingClientRect();
        const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        // If we're in an XR session and we have a hitTestSource, prefer using hit-test
        if (xrSession && hitTestSource) {
          // We cannot directly call frame from here; but we can request a transient hit test by using viewer space hit test using getFrame via a temporary requestAnimationFrame callback.
          // Simpler: attempt to use the last known reticle position. If reticle visible, consider this a placement/touch.
          if (reticle.visible) {
            // If object is close to reticle, toggle color instead of re-placing
            const retPos = new THREE.Vector3().setFromMatrixPosition(reticle.matrix);
            const objPos = new THREE.Vector3();
            object3D.getWorldPosition(objPos);
            const dist = retPos.distanceTo(objPos);
            if (dist < 0.12) {
              cycleColor();
              return;
            } else {
              // place object at reticle position
              placeAtMatrix(reticle.matrix);
              return;
            }
          } else {
            // no reticle — ignore or inform user
            console.log('No hit at tap location (reticle not visible).');
            return;
          }
        }

        // Non-AR: use raycaster against scene
        const pointer = new THREE.Vector2(x, y);
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(pointer, camera);
        const intersects = raycaster.intersectObject(object3D, true);
        if (intersects.length > 0) {
          // tapped the object -> change color
          cycleColor();
          return;
        }

        // Intersect with ground plane (y=0) to place object
        const planeY = 0;
        const origin = raycaster.ray.origin;
        const dir = raycaster.ray.direction;
        if (Math.abs(dir.y) > 1e-6) {
          const t = (planeY - origin.y) / dir.y;
          if (t > 0) {
            const p = origin.clone().add(dir.clone().multiplyScalar(t));
            // build matrix from position, preserve default rotation
            const m = new THREE.Matrix4();
            m.makeTranslation(p.x, p.y, p.z);
            placeAtMatrix(m);
            return;
          }
        }
      }

      // Place the object at a given matrix (Matrix4).
      // Try to create an XR anchor for stability; if not available, save the matrix to reapply each frame.
      async function placeAtMatrix(matrix) {
        // apply to object immediately (also disable object auto updates)
        object3D.matrixAutoUpdate = false;
        object3D.visible = true;
        object3D.matrix.copy(matrix);

        // try to create XR anchor if in session
        if (xrSession && xrRefSpace && xrSession.requestAnimationFrame) {
          try {
            if (xrSession.requestHitTestSourceForTransientInput) {
              // Not needed here; we'll try anchors from a hit test result if available.
            }
            // If an anchor creation API is available via hit test result, we would use it.
            // We'll attempt to create an anchor from the matrix by converting it into an XRRigidTransform
            if (xrSession.createAnchor) {
              // create transform from the matrix
              const pos = new THREE.Vector3();
              const quat = new THREE.Quaternion();
              const scale = new THREE.Vector3();
              matrix.decompose(pos, quat, scale);
              const xrTransform = new XRRigidTransform(
                { x: pos.x, y: pos.y, z: pos.z },
                { x: quat.x, y: quat.y, z: quat.z, w: quat.w }
              );
              // create anchor in reference space
              const created = await xrSession.createAnchor(xrTransform, xrRefSpace).catch(()=>null);
              if (created) {
                anchor = created;
                console.log('Anchor created and object is now sticky via XRAnchor.');
              } else {
                // fallback: save matrix
                savedPoseMatrix = matrix.clone();
                console.log('Anchor unavailable; saved matrix for sticky placement.');
              }
            } else {
              // no anchor API — save matrix fallback
              savedPoseMatrix = matrix.clone();
              console.log('Anchor API not available; saved matrix for sticky placement.');
            }
          } catch (e) {
            console.warn('Anchor creation failed, falling back to matrix store.', e);
            savedPoseMatrix = matrix.clone();
          }
        } else {
          // not in XR session -> local placement (preview)
          savedPoseMatrix = matrix.clone();
        }

        placed = true;
      }

      function cycleColor() {
        colorIndex = (colorIndex + 1) % colors.length;
        if (object3D && object3D.material) {
          object3D.material.color.setHex(colors[colorIndex]);
        } else if (object3D && object3D.children && object3D.children.length) {
          // in case of nested meshes
          object3D.traverse((c) => { if (c.isMesh && c.material) c.material.color.setHex(colors[colorIndex]); });
        }
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // XR start button / checks
      async function checkSupportedState() {
        if (!navigator.xr) {
          xrButton.innerText = 'AR not available';
          xrButton.disabled = true;
          warningZone.innerText = 'navigator.xr not available — try Chrome on Android with ARCore installed.';
          return;
        }
        try {
          const supported = await navigator.xr.isSessionSupported('immersive-ar');
          if (supported) {
            xrButton.innerText = 'Enter AR';
            xrButton.disabled = false;
          } else {
            xrButton.innerText = 'AR not supported';
            xrButton.disabled = true;
            warningZone.innerText = 'immersive-ar not supported on this device/browser.';
          }
        } catch (e) {
          xrButton.innerText = 'AR check failed';
          xrButton.disabled = true;
          console.error('isSessionSupported error', e);
          warningZone.innerText = 'Error checking AR support — see console.';
        }
      }

      // Create session when user presses the button
      async function onXRButtonClicked() {
        if (!xrSession) {
          // Request immersive-ar with hit-test (optional) and DOM overlay
          const sessionInit = {
            optionalFeatures: ['dom-overlay', 'hit-test', 'anchors', 'local-floor'],
            domOverlay: { root: document.getElementById('overlay') }
          };
          try {
            const session = await navigator.xr.requestSession('immersive-ar', sessionInit);
            onSessionStarted(session);
          } catch (err) {
            alert('Failed to start AR session: ' + (err && err.message ? err.message : err));
            console.error(err);
          }
        } else {
          xrSession.end();
        }
      }

      // Session start
      async function onSessionStarted(session) {
        xrSession = session;
        sessionInfo.innerText = 'Session started';
        xrButton.innerText = 'Exit AR';
        xrButton.disabled = false;

        // Use three.js to manage the session
        try {
          renderer.xr.enabled = true;
          renderer.xr.setReferenceSpaceType('local'); // prefer local (or local-floor)
          await renderer.xr.setSession(session);
        } catch (e) {
          console.error('three.js xr setSession failed, falling back to manual XRWebGLLayer. Error:', e);
          // fallback (rare) — try manual approach
          const gl = renderer.getContext();
          await gl.makeXRCompatible();
          session.updateRenderState({ baseLayer: new XRWebGLLayer(session, gl) });
        }

        // request reference space & hit-test source
        xrRefSpace = await session.requestReferenceSpace('local-floor').catch(()=>null) || await session.requestReferenceSpace('local');
        const viewerSpace = await session.requestReferenceSpace('viewer').catch(()=>null);
        if (viewerSpace && session.requestHitTestSource) {
          session.requestHitTestSource({ space: viewerSpace }).then((source) => {
            hitTestSource = source;
          }).catch((e) => { console.warn('Hit test source request failed:', e); });
        }

        // handle end
        session.addEventListener('end', onSessionEnded);

        // Try to listen to select events from XR input sources (tap in AR)
        session.addEventListener('select', (ev) => {
          // If we have a hit test source and a reticle we already place on tap — but handle select to toggle color if close
          if (reticle && reticle.visible) {
            const retPos = new THREE.Vector3().setFromMatrixPosition(reticle.matrix);
            const objPos = new THREE.Vector3();
            object3D.getWorldPosition(objPos);
            const dist = retPos.distanceTo(objPos);
            if (dist < 0.12) {
              cycleColor();
            } else {
              placeAtMatrix(reticle.matrix);
            }
          }
        });

        // Inform overlay about DOM overlay support
        if (session.domOverlayState) {
          sessionInfo.innerText = 'DOM Overlay type: ' + session.domOverlayState.type;
        } else {
          sessionInfo.innerText = 'DOM Overlay not enabled.';
        }
      }

      function onSessionEnded() {
        xrSession = null;
        sessionInfo.innerText = '';
        xrButton.innerText = 'Enter AR';
        hitTestSource = null;
        anchor = null;
        savedPoseMatrix = null;
        placed = false;
        // return to preview mode: ensure object visible and at origin
        object3D.matrixAutoUpdate = true;
        object3D.position.set(0,0,0);
        object3D.rotation.set(0,0,0);
      }

      // Render loop — will receive XRFrame when in AR
      function render(time, xrFrame) {
        // If we're in XR and have a frame, update reticle from hit test
        if (xrFrame && xrSession) {
          if (hitTestSource) {
            const hitResults = xrFrame.getHitTestResults(hitTestSource);
            if (hitResults.length > 0) {
              const hit = hitResults[0];
              const pose = hit.getPose(xrRefSpace);
              if (pose) {
                // copy pose into reticle
                const mat = new THREE.Matrix4().fromArray(pose.transform.matrix);
                reticle.visible = true;
                reticle.matrix.copy(mat);
              } else {
                reticle.visible = false;
              }
            } else {
              reticle.visible = false;
            }
          }

          // If we have an anchor, update object's matrix from its anchor space pose
          if (anchor) {
            try {
              const anchorPose = xrFrame.getPose(anchor.anchorSpace, xrRefSpace);
              if (anchorPose) {
                object3D.matrix.fromArray(anchorPose.transform.matrix);
                object3D.matrixAutoUpdate = false;
              }
            } catch (e) {
              // ignore if anchor pose not available this frame
            }
          } else if (savedPoseMatrix) {
            // fallback: reapply the saved matrix so object stays in the same world spot
            object3D.matrix.copy(savedPoseMatrix);
            object3D.matrixAutoUpdate = false;
          }

          // viewer pose (for diagnostics)
          const viewerPose = xrFrame.getViewerPose(xrRefSpace);
          if (viewerPose) {
            const p = viewerPose.transform.position;
            poseInfo.innerText = `Viewer: ${p.x.toFixed(3)}, ${p.y.toFixed(3)}, ${p.z.toFixed(3)}`;
          } else {
            poseInfo.innerText = '(no viewer pose)';
          }
        } else {
          // preview mode: show simple rotation if not placed
          if (!placed) {
            object3D.rotation.y += 0.004;
          } else if (object3D.matrixAutoUpdate === false && savedPoseMatrix) {
            // when in preview and we've stored a matrix (from click), apply it to keep object sticky
            object3D.matrix.copy(savedPoseMatrix);
          }
        }

        // Render scene
        renderer.render(scene, camera);
      }

      // Initialize everything
      initThree();
      checkSupportedState();

      // Hook up UI button
      xrButton.addEventListener('click', onXRButtonClicked);

      // Make sure canvas is xr-compatible if a session is started by other routes
      if (navigator.xr) {
        navigator.xr.addEventListener('devicechange', checkSupportedState);
      }
    </script>
  </body>
</html>
