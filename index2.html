<!doctype html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
    <meta name='mobile-web-app-capable' content='yes'>
    <meta name='apple-mobile-web-app-capable' content='yes'>
    <link rel='icon' type='image/png' sizes='32x32' href='favicon-32x32.png'>
    <link rel='icon' type='image/png' sizes='96x96' href='favicon-96x96.png'>
    <link rel='stylesheet' href='css/common.css'>

    <title>AR 3D Object</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        background: #000;
        color: #fff;
        font-family: Arial, sans-serif;
      }
      
      #overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        z-index: 1000;
        pointer-events: none;
      }
      
      #overlay > * {
        pointer-events: auto;
      }
      
      .barebones-button {
        background: #007acc;
        color: white;
        border: none;
        padding: 10px 20px;
        font-size: 16px;
        border-radius: 5px;
        cursor: pointer;
      }
      
      .barebones-button:disabled {
        background: #666;
        cursor: not-allowed;
      }

      main {
        text-align: center;
        padding: 50px;
      }

      #instructions {
        background: rgba(0,0,0,0.8);
        padding: 10px;
        border-radius: 5px;
        margin: 10px;
      }
    </style>
  </head>
  <body>
    <div id="overlay">
      <header>
        <details open>
          <summary>AR 3D Object Demo</summary>
          <p>
            This demo places a color-changing 3D cube in AR space. 
            Tap the screen to place cubes at detected surfaces.
            <a class="back" href="./index.html">Back</a>
          </p>
          <div id="session-info"></div>
          <div id="pose"></div>
          <div id="instructions" style="display: none;">
            Tap to place a cube on detected surfaces
          </div>
          <div id="warning-zone"></div>
          <button id="xr-button" class="barebones-button" disabled>XR not found</button>
        </details>
      </header>
    </div>
    <main style='text-align: center;'>
      <p>Click 'Enter AR' to see 3D content</p>
    </main>

    <script type="module">
      // XR globals
      let xrButton = document.getElementById('xr-button');
      let xrSession = null;
      let xrRefSpace = null;
      let hitTestSource = null;

      // WebGL scene globals
      let gl = null;
      let shaderProgram = null;
      let cubeBuffer = null;
      let indexBuffer = null;
      let reticle = null;
      let placedCubes = [];

      // Matrix math utilities
      class Mat4 {
        static create() {
          return new Float32Array(16);
        }

        static identity(out) {
          out[0] = 1; out[1] = 0; out[2] = 0; out[3] = 0;
          out[4] = 0; out[5] = 1; out[6] = 0; out[7] = 0;
          out[8] = 0; out[9] = 0; out[10] = 1; out[11] = 0;
          out[12] = 0; out[13] = 0; out[14] = 0; out[15] = 1;
          return out;
        }

        static multiply(out, a, b) {
          let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
          let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
          let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
          let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

          let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
          out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
          out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
          out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
          out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

          b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
          out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
          out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
          out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
          out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

          b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
          out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
          out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
          out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
          out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

          b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
          out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
          out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
          out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
          out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
          return out;
        }

        static translate(out, a, v) {
          let x = v[0], y = v[1], z = v[2];
          out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
          out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];
          out[8] = a[8]; out[9] = a[9]; out[10] = a[10]; out[11] = a[11];
          out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
          out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
          out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
          out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
          return out;
        }

        static scale(out, a, v) {
          let x = v[0], y = v[1], z = v[2];
          out[0] = a[0] * x; out[1] = a[1] * x; out[2] = a[2] * x; out[3] = a[3] * x;
          out[4] = a[4] * y; out[5] = a[5] * y; out[6] = a[6] * y; out[7] = a[7] * y;
          out[8] = a[8] * z; out[9] = a[9] * z; out[10] = a[10] * z; out[11] = a[11] * z;
          out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
          return out;
        }
      }

      // Shader source code
      const vertexShaderSource = `
        attribute vec4 aVertexPosition;
        attribute vec3 aVertexNormal;
        
        uniform mat4 uModelViewMatrix;
        uniform mat4 uProjectionMatrix;
        uniform mat4 uNormalMatrix;
        uniform vec3 uColor;
        uniform float uTime;
        
        varying vec3 vColor;
        varying vec3 vNormal;
        
        void main(void) {
          gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
          vNormal = (uNormalMatrix * vec4(aVertexNormal, 0.0)).xyz;
          
          // Animate color based on time and position
          float colorShift = sin(uTime * 0.002 + aVertexPosition.x + aVertexPosition.y) * 0.5 + 0.5;
          vColor = mix(uColor, vec3(1.0 - uColor.r, 1.0 - uColor.g, 1.0 - uColor.b), colorShift);
        }
      `;

      const fragmentShaderSource = `
        precision mediump float;
        
        varying vec3 vColor;
        varying vec3 vNormal;
        
        void main(void) {
          // Simple lighting
          vec3 lightDirection = normalize(vec3(1.0, 1.0, 1.0));
          float lightIntensity = max(dot(normalize(vNormal), lightDirection), 0.3);
          
          gl_FragColor = vec4(vColor * lightIntensity, 0.9);
        }
      `;

      // Create and compile shader
      function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
          gl.deleteShader(shader);
          return null;
        }

        return shader;
      }

      // Initialize shader program
      function initShaderProgram(gl) {
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
          console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
          return null;
        }

        return shaderProgram;
      }

      // Create cube geometry
      function initBuffers(gl) {
        // Cube vertices with normals
        const vertices = new Float32Array([
          // Front face
          -0.1, -0.1,  0.1,  0.0,  0.0,  1.0,
           0.1, -0.1,  0.1,  0.0,  0.0,  1.0,
           0.1,  0.1,  0.1,  0.0,  0.0,  1.0,
          -0.1,  0.1,  0.1,  0.0,  0.0,  1.0,

          // Back face
          -0.1, -0.1, -0.1,  0.0,  0.0, -1.0,
          -0.1,  0.1, -0.1,  0.0,  0.0, -1.0,
           0.1,  0.1, -0.1,  0.0,  0.0, -1.0,
           0.1, -0.1, -0.1,  0.0,  0.0, -1.0,

          // Top face
          -0.1,  0.1, -0.1,  0.0,  1.0,  0.0,
          -0.1,  0.1,  0.1,  0.0,  1.0,  0.0,
           0.1,  0.1,  0.1,  0.0,  1.0,  0.0,
           0.1,  0.1, -0.1,  0.0,  1.0,  0.0,

          // Bottom face
          -0.1, -0.1, -0.1,  0.0, -1.0,  0.0,
           0.1, -0.1, -0.1,  0.0, -1.0,  0.0,
           0.1, -0.1,  0.1,  0.0, -1.0,  0.0,
          -0.1, -0.1,  0.1,  0.0, -1.0,  0.0,

          // Right face
           0.1, -0.1, -0.1,  1.0,  0.0,  0.0,
           0.1,  0.1, -0.1,  1.0,  0.0,  0.0,
           0.1,  0.1,  0.1,  1.0,  0.0,  0.0,
           0.1, -0.1,  0.1,  1.0,  0.0,  0.0,

          // Left face
          -0.1, -0.1, -0.1, -1.0,  0.0,  0.0,
          -0.1, -0.1,  0.1, -1.0,  0.0,  0.0,
          -0.1,  0.1,  0.1, -1.0,  0.0,  0.0,
          -0.1,  0.1, -0.1, -1.0,  0.0,  0.0,
        ]);

        const indices = [
          0,  1,  2,      0,  2,  3,    // front
          4,  5,  6,      4,  6,  7,    // back
          8,  9,  10,     8,  10, 11,   // top
          12, 13, 14,     12, 14, 15,   // bottom
          16, 17, 18,     16, 18, 19,   // right
          20, 21, 22,     20, 22, 23,   // left
        ];

        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

        return {
          vertex: vertexBuffer,
          index: indexBuffer,
          vertexCount: indices.length
        };
      }

      // Draw cube at specified transform with color
      function drawCube(gl, buffers, shaderProgram, projectionMatrix, modelViewMatrix, color, time) {
        // Bind vertex buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, buffers.vertex);
        
        const vertexPosition = gl.getAttribLocation(shaderProgram, 'aVertexPosition');
        const vertexNormal = gl.getAttribLocation(shaderProgram, 'aVertexNormal');
        
        gl.vertexAttribPointer(vertexPosition, 3, gl.FLOAT, false, 24, 0);
        gl.enableVertexAttribArray(vertexPosition);
        
        gl.vertexAttribPointer(vertexNormal, 3, gl.FLOAT, false, 24, 12);
        gl.enableVertexAttribArray(vertexNormal);

        // Bind index buffer
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.index);

        // Set uniforms
        gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'), false, projectionMatrix);
        gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'), false, modelViewMatrix);
        gl.uniformMatrix4fv(gl.getUniformLocation(shaderProgram, 'uNormalMatrix'), false, modelViewMatrix);
        gl.uniform3fv(gl.getUniformLocation(shaderProgram, 'uColor'), color);
        gl.uniform1f(gl.getUniformLocation(shaderProgram, 'uTime'), time);

        // Draw
        gl.drawElements(gl.TRIANGLES, buffers.vertexCount, gl.UNSIGNED_SHORT, 0);
      }

      function checkSupportedState() {
        navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
          if (supported) {
            xrButton.innerHTML = 'Enter AR';
          } else {
            xrButton.innerHTML = 'AR not found';
          }
          xrButton.disabled = !supported;
        });
      }

      function initXR() {
        if (!window.isSecureContext) {
          let message = "WebXR unavailable due to insecure context";
          document.getElementById("warning-zone").innerText = message;
        }

        if (navigator.xr) {
          xrButton.addEventListener('click', onButtonClicked);
          navigator.xr.addEventListener('devicechange', checkSupportedState);
          checkSupportedState();
        }
      }

      function onButtonClicked() {
        if (!xrSession) {
          navigator.xr.requestSession('immersive-ar', {
            requiredFeatures: ['hit-test'],
            optionalFeatures: ['dom-overlay'],
            domOverlay: {root: document.getElementById('overlay')}
          }).then(onSessionStarted, onRequestSessionError);
        } else {
          xrSession.end();
        }
      }

      function onSessionStarted(session) {
        xrSession = session;
        xrButton.innerHTML = 'Exit AR';
        document.getElementById('instructions').style.display = 'block';

        if (session.domOverlayState) {
          document.getElementById('session-info').innerHTML = 'DOM Overlay type: ' + session.domOverlayState.type;
        }

        session.addEventListener('end', onSessionEnded);
        session.addEventListener('select', onSelect);

        let canvas = document.createElement('canvas');
        gl = canvas.getContext('webgl', {
          xrCompatible: true
        });

        // Initialize WebGL resources
        shaderProgram = initShaderProgram(gl);
        cubeBuffer = initBuffers(gl);

        // Enable depth testing and blending
        gl.enable(gl.DEPTH_TEST);
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

        session.updateRenderState({ baseLayer: new XRWebGLLayer(session, gl) });
        
        session.requestReferenceSpace('local').then((refSpace) => {
          xrRefSpace = refSpace;
          
          // Request hit test source
          session.requestHitTestSource({ space: refSpace }).then((source) => {
            hitTestSource = source;
          });
          
          session.requestAnimationFrame(onXRFrame);
        });
      }

      function onRequestSessionError(ex) {
        alert("Failed to start immersive AR session.");
        console.error(ex.message);
      }

      function onSessionEnded(event) {
        xrSession = null;
        xrButton.innerHTML = 'Enter AR';
        document.getElementById('session-info').innerHTML = '';
        document.getElementById('instructions').style.display = 'none';
        hitTestSource = null;
        placedCubes = [];
        gl = null;
      }

      function onSelect(event) {
        if (reticle && hitTestSource) {
          // Place a cube at the reticle position
          const cube = {
            transform: new Float32Array(reticle.transform.matrix),
            color: [Math.random(), Math.random(), Math.random()],
            time: Date.now()
          };
          placedCubes.push(cube);
          console.log('Cube placed at', cube.transform[12], cube.transform[13], cube.transform[14]);
        }
      }

      function onXRFrame(t, frame) {
        let session = frame.session;
        session.requestAnimationFrame(onXRFrame);

        gl.bindFramebuffer(gl.FRAMEBUFFER, session.renderState.baseLayer.framebuffer);

        const width = session.renderState.baseLayer.framebufferWidth;
        const height = session.renderState.baseLayer.framebufferHeight;
        gl.viewport(0, 0, width, height);

        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        let pose = frame.getViewerPose(xrRefSpace);
        if (pose) {
          const p = pose.transform.position;
          document.getElementById('pose').innerText = "Position: " +
            p.x.toFixed(3) + ", " + p.y.toFixed(3) + ", " + p.z.toFixed(3);

          // Handle hit testing
          if (hitTestSource) {
            const hitTestResults = frame.getHitTestResults(hitTestSource);
            if (hitTestResults.length > 0) {
              const hit = hitTestResults[0];
              reticle = hit.getPose(xrRefSpace);
            }
          }

          gl.useProgram(shaderProgram);

          for (let view of pose.views) {
            let viewport = session.renderState.baseLayer.getViewport(view);
            gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);

            // Draw placed cubes
            placedCubes.forEach((cube) => {
              const currentTime = Date.now();
              const age = currentTime - cube.time;
              
              // Create model matrix from stored transform
              const modelMatrix = Mat4.create();
              modelMatrix.set(cube.transform);
              
              // Scale the cube
              const scaleMatrix = Mat4.create();
              Mat4.identity(scaleMatrix);
              Mat4.scale(scaleMatrix, scaleMatrix, [1, 1, 1]);
              
              const finalMatrix = Mat4.create();
              Mat4.multiply(finalMatrix, modelMatrix, scaleMatrix);
              
              // Combine with view matrix
              const modelViewMatrix = Mat4.create();
              Mat4.multiply(modelViewMatrix, view.transform.inverse.matrix, finalMatrix);

              drawCube(gl, cubeBuffer, shaderProgram, view.projectionMatrix, modelViewMatrix, cube.color, currentTime);
            });

            // Draw reticle (simple ring)
            if (reticle) {
              const reticleMatrix = Mat4.create();
              reticleMatrix.set(reticle.transform.matrix);
              
              const scaleMatrix = Mat4.create();
              Mat4.identity(scaleMatrix);
              Mat4.scale(scaleMatrix, scaleMatrix, [0.5, 0.02, 0.5]);
              
              const finalMatrix = Mat4.create();
              Mat4.multiply(finalMatrix, reticleMatrix, scaleMatrix);
              
              const modelViewMatrix = Mat4.create();
              Mat4.multiply(modelViewMatrix, view.transform.inverse.matrix, finalMatrix);

              drawCube(gl, cubeBuffer, shaderProgram, view.projectionMatrix, modelViewMatrix, [0, 1, 1], Date.now());
            }
          }
        } else {
          document.getElementById('pose').innerText = "Position: (null pose)";
        }
      }

      initXR();
    </script>
  </body>
</html>
